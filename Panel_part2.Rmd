---
title: "2) Extensions"
author: "Tobias Rüttenauer"
date: "December 03, 2021"
output_dir: docs
output: 
  html_document:
    theme: flatly
    highlight: haddock
    code_folding: show
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: false
    toc_depth: 2
theme: united
bibliography: Panel.bib
link-citations: yes
---

\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\tr}{\mathrm{tr}}
\newcommand{\plim}{\operatornamewithlimits{plim}}
\newcommand{\diag}{\mathrm{diag}}
\newcommand{\E}{\mathrm{E}}
\newcommand{\Prob}{\mathrm{Prob}}
\newcommand{\bm}[1]{\boldsymbol{\mathbf{#1}}}

### Required packages

```{r, message = FALSE, warning = FALSE, results = 'hide'}
pkgs <- c("plm", "feisr", "did", "panelView", "texreg", "tidyr", "dplyr", "ggplot2", "ggforce") 
lapply(pkgs, require, character.only = TRUE)
```

### Session info

```{r}
sessionInfo()

```

# Outline

* Fixed Effects Individual Slopes

* Dynamic treatment effects

* TBD: Dynamic Diff-in-Diff

* TBD: Synthetic Control

* TBD: Generalized Synthetic Control


# Fixed Effects Individual Slopes (FEIS)


Remeber that we have to make the parallel trends assumption in twoways FE models. A violation of the parallel trends assumption leads to biased estimates. Usually, when controlling for time or time fixed effects, we make the assumption that every observation experiences the same "effect of time".

However, we can relax this assumption by giving each individual their own intercept __and__ their own slope.

The fixed effects individual slope (FEIS) estimator is a more general version of the well-known fixed effects estimator (FE), which allows to control for heterogeneous slopes in addition to time-constant heterogeneity [e.g. @Bruderl.2015.387; @Polachek.1994.0; @Ruttenauer.2020; @Wooldridge.2010.384]. Formally, the FEIS estimator can be expressed as 

$$
\begin{align} 
\bm y_{i} =& \bm X_{i}\bm\beta + \bm W_i \bm\alpha_i + \bm \epsilon_{i},
\end{align}
$$
where $\bm y_{i}$ is $T \times 1$, $\bm X_{i}$ is $T \times K$, and $\bm\epsilon_{i}$ is $T \times 1$. $\bm W_i$ is a $T \times J$ matrix of slope variables, and $\bm\alpha_i$ a $J \times 1$ vector of individual-specific slope parameters, for $J$ slope parameters including a constant term. If $\bm W_i$ consists of a constant term only, $\bm W_i = \bm 1$, thus $\bm\alpha_i$ reduces to $\alpha_{i1}$, and the above equation represents the well-known formula of a conventional FE model with individual fixed effects.

As with the conventional FE, FEIS can be estimated using `lm()` by including $N-1$ individual-specific dummies and interaction terms of each slope variable with the $N-1$ individual-specific dummies ($(N-1) *J$ controls). This is however highly inefficient. As with the conventional FE estimator, we can achieve the same result by running an `lm()` on pre-transformed data. Therefore, specify the 'residual maker' matrix $\bm M_i = \bm I_T - \bm W_i(\bm W^\intercal_i \bm W_i)^{-1}\bm W^\intercal_i$, and estimate
$$
\begin{align} 
y_{it} - \hat{y}_{it} =& (\bm x_{it} - \hat{\bm x}_{it})\bm\beta + \epsilon_{it} - \hat{\epsilon}_{it}, \\
\bm M_i \bm y_i =& \bm M_i \bm X_i\bm\beta + \bm M_i \bm \epsilon_{i}, \\
\tilde{\bm y}_{i} =& \tilde{\bm X}_{i}\bm\beta + \tilde{\bm \epsilon}_{i},
\end{align} 
$$
where $\tilde{\bm y}_{i}$, $\tilde{\bm X}_{i}$, and $\tilde{\bm \epsilon}_{i}$ are the residuals of regressing $\bm y_{i}$, each column-vector of $\bm X_{i}$, and $\bm \epsilon_{i}$ on $\bm W_i$. Intuitively, we (1) estimate the individual-specific predicted values for the dependent variable and each covariate based on an individual intercept and the additional slope variables of $\bm W_i$, (2) 'detrend' the original data by these individual-specific predicted values, and (3) run an OLS model on the residual data. 

Similarly, we can estimate a correlated random effects (CRE) model [@Chamberlain.1982; @Mundlak.1978.0; @Wooldridge.2010.384] including the individual specific predictions $\hat{\bm X}_{i}$ to obtain the FEIS estimator:
$$
\begin{align} 
\bm y_{i} =& \bm X_{i}\bm\beta + \hat{\bm X}_{i}\bm\rho + \bm \epsilon_{i}.
\end{align}
$$


### Example

As an example, we use the `mwp` panel data, containing information on wages and family status of 268 men. This is a random sample drawn from the National Longitudinal Survey of Youth [@NLSY79.2012], and more details on the selection of observations and variable construction can be found in @Ludwig.2018.0. 

```{r}
data("mwp", package = "feisr")
head(mwp)
```

The data set contains a unique person identifier (`id`) and survey year indicator (`year`). Furthermore, we have information about the log hourly wage rate (`lnwage`), work experience (`exp`) and its square (`expq`), family status (`marry`), enrollment in current education (`enrol`), years of formal education education (`yeduc`), age (`age`), birth cohort (`cohort`), and a grouped year indicator (`yeargr`).

we exemplary investigate the 'marriage wage premium': we analyze whether marriage leads to an increase in the hourly wage for men. We use the function `feis` to estimate fixed effects individual slope models to control for the hypothesis that those men who are more likely to marry or marry earlier, also have a steeper wage growth over time.

Let's start with our most common panel models (FE and RE):

```{r}
wages.fe <- plm(lnw ~ marry + enrol + yeduc + as.factor(yeargr)
                + exp + I(exp^2), data = mwp, index = c("id", "year"),
                model = "within", effect = "individual")
wages.re <- plm(lnw ~ marry + enrol + yeduc + as.factor(yeargr)
                + exp + I(exp^2), data = mwp, index = c("id", "year"),
                model = "random", effect = "individual")
summary(wages.fe)
```

and we calculate panel robust standard errors and attach them back to the model output:

```{r}
# Calculate vcov
vcovx_fe <- vcovHC(wages.fe, cluster = "group", method = "arellano", type = "HC3")
vcovx_re <- vcovHC(wages.re, cluster = "group", method = "arellano", type = "HC3")

# Replace original vcov in output
wages.fe$vcov <- vcovx_fe
wages.re$vcov <- vcovx_re
```

Replacing has the advantage that we know use the cluster robust SEs in all following operations (like `summary()` or `screenreg`).

```{r}
summary(wages.fe)
```

And now, we allow the individual specific trends. To replicate the analysis of @Ludwig.2018.0, we use work experience (`exp`) and squared work experience as the slope variables.

__One mayor advantage of using work experience as slope it that we can still control for (grouped) time fixed effects__

__Assuming linear trends (only using exp), is a strong assumption. However, for each additional slope (e.g. polynomial), FEIS becomes more data hungry: each individual needs at least $T \geq K + 1$ observations to contribute to the model. If not, they are dropped!__

Here we use `feis` with panel robust standard errors. The command `felm` from `lfe` can be used to calculate individual slopes as well.

```{r}
wages.feis <- feis(lnw ~ marry + enrol + yeduc + as.factor(yeargr)
                   | exp + I(exp^2), data = mwp, id = "id",
                   robust = TRUE)
summary(wages.feis)
```

Let's compare the results.

```{r}
screenreg(list(wages.re, wages.fe, wages.feis), digits = 3,
          custom.model.names = c("RE", "FE", "FEIS"))
```

Interpretation:

* RE: Married observations have a significantly higher wage than unmarried observations.

* FE: If people marry, they experience an increase in wages afterwards. The effect is significant and slightly lower than the RE.

* FEIS: Accounting for the individual wage trend before marriage, we do not observe an increase in wages if people marry. The effect is small and non-significant.

Overall, this indicated that there is a problem with non-parallel trends: Those with steeper wage trajectories are more likely to marry (or marry earlier).

# Dynamic treatment effects

Often, we are not only interested in the overall treatment effect, but we also want to know how treatment effects unfold after a treatment. For example, how does happiness change around specific life course events [@Clark.2013], or how do housing prices develop after the opening of an industrial plant [@Currie.2015]?

There are various ways of calculating how a treatment effect develops over time:

![Brüderl/Ludwig 2019, https://www.ls3.soziologie.uni-muenchen.de/studium-lehre/archiv/teaching-marterials/panel-analysis_april-2019.pdf](fig/Impact-function.PNG)

Usually, it is best to not impose a structural form, but rather to use dummy impact functions. However, even with this, there is an ongoing debate on what is the best choice of specification [@Ludwig.2021], or see for instance [blog post by Pedro H. C. Sant’Anna and Brantly Callaway](https://pedrohcgs.github.io/posts/twfe).

__Note that these settings usually require a staggered treatment adoption: individuals are treated once, and afterwards reamin treated__

There are many cases where this does not apply. However, one can think about potential ways of artificially creating such designs:

* Dichotomize continuous treatments (if theoretically plausible!)

* Create id-period splits. E.g. if a person gets divorced, either drop from sample, or treat as a "new id" as a person can re-marry (note that this assumes that first and second marriage have equal effects).

### Example

We stick with our example and try to estimate how the wage changes around the year of marriage.

To do so, we first estimate make sure the data is ordered by id and time

```{r}
mwp <- mwp[order(mwp$id, mwp$year), ]
head(mwp[, 1:6], n = 20)
```

Then, we make sure that our data looks like a staggered treatment design. Are there people who jump from married to not married in the data?

```{r}
# Change in marriage status within an id
mwp$fd_marry <- ave(mwp$marry,
                    mwp$id,
                    FUN = function(x) x - dplyr::lag(x, 1, default = 0)) # 0 insteat of NA for 1st year

# Mark observations starting with a negative fd value (jump from marry=1 to marry =0)
mwp$notstag_marry <- ave(ifelse(mwp$fd_marry == -1, 1, 0),
                         mwp$id,
                         FUN = function(x) cumsum(x))
table(mwp$fd_marry)
table(mwp$notstag_marry)
```

Luckily, the dataset is already cleaned: there are only transitions into marriage, not out of marriage.

Next we want to make sure if there are any individuals who already start with the treatment (who are married right from their first wave on).

__We only want to have those in our sample who potentially can go from not-treated to treated!__

```{r}
mwp <- mwp[order(mwp$id, mwp$year), ] # just to be sure

# Person year number
mwp$pynr <- ave(mwp$year,
                mwp$id,
                FUN = function(x) 1:length(x))

# Marry status at first wave
mwp$f_marry <- ifelse(mwp$pynr == 1, mwp$marry, NA)

# Distribute across individual, using mean and na.rm = TRUE
mwp$f_marry <- ave(mwp$f_marry,
                   mwp$id,
                   FUN = function(x) mean(x, na.rm = TRUE))

table(mwp$f_marry)
```

Again, someone has already done the job. There are no individuals who start married in the first wave.

We can also look at this graphically with `panelView` (mainly helpful for small N data):

```{r, fig.height = 10, fig.width = 5}
panelView(lnw ~ marry, 
          data = mwp, index = c("id","year"),
          type = "treat", theme.bw = TRUE)
```

Alright, so lets create a dummy impact function / a count variable around the treatment.

```{r}
mwp <- mwp[order(mwp$id, mwp$year), ] # just to be sure!!

# Function that creates distance to the treatment (assuming 0=control, 1=treated)
impfun <- function(x, default = -99){
  nas <- which(is.na(x))  #save nas
  ft <- which(x == 1)[1]  #first teatment index
  if(is.na(ft)){          #replicate default if never treated
    count <- rep(default, length(x))
  }else{
    ri <- 1:length(x)       #running index
    count <- ri - ft        #distance to first treatment
  }
  if(length(nas) != 0){   #replace nas if any
    count[nas] <- NA
  }
  return(count)           #return counter
}

# Apply to each individual
mwp$marry_if <- ave(mwp$marry,
                    mwp$id,
                    FUN = function(x) impfun(x))

head(mwp[, c("id", "year", "marry", "marry_if")], n = 50)
```

We can now use this time count function to estimate dynamic treatment effects. 

Note that we need to make to important decisions ([blog post by Pedro H. C. Sant’Anna and Brantly Callaway](https://pedrohcgs.github.io/posts/twfe)):

* Which dates to use a reference category

* How many pre-treatment periods to include (to test for anticipation or potential pre-treatment differences)

Here, re will just include three periods before marriage and use the rest as reference categories

```{r}
# Set all before -3 to -99
mwp$marry_if[mwp$marry_if < -3 & mwp$marry_if > -99] <- -99

# Make factor with -99 as reference category
mwp$marry_if <- as.factor(mwp$marry_if)
mwp$marry_if <- relevel(mwp$marry_if, "-99")

```

And we use this as our treatment variable in the FE estimator.

```{r}
# Standard marriage indicator
wages.fe <- plm(lnw ~ marry + enrol + yeduc + as.factor(yeargr)
                + exp + I(exp^2), data = mwp, index = c("id", "year"),
                model = "within", effect = "individual")

# with dummy impact function
wages2.fe <- plm(lnw ~ marry_if + enrol + yeduc + as.factor(yeargr)
                 + exp + I(exp^2), data = mwp, index = c("id", "year"),
                 model = "within", effect = "individual")

# add cluster robust SEs
vcovx_fe2 <- vcovHC(wages2.fe, cluster = "group", method = "arellano", type = "HC3")
wages2.fe$vcov <- vcovx_fe2


summary(wages2.fe)
```

Let's plot that

```{r}
# Set up results matrix
coef.df <- data.frame(matrix(NA,
                  nrow = (length(levels(mwp$marry_if)) - 1),
                  ncol = 3))
colnames(coef.df) <- c("time", "att", "se")

# paste results
coef.df$time <- c(-3:14)
output <- summary(wages2.fe)$coefficients
coef.df[, c("att", "se")] <- output[which(grepl("marry_if", rownames(output))), 1:2]

# 95% CI
interval2  <-  -qnorm((1-0.95)/2)  # 95% multiplier
coef.df$ll <- coef.df$att - coef.df$se*interval2
coef.df$ul <- coef.df$att + coef.df$se*interval2

# Plot
zp1 <- ggplot(coef.df[coef.df$time < 7, ], 
              aes(x = time, y = att)) +  
  geom_pointrange(aes(x = time, y = att, ymin = ll, ymax = ul),
                                lwd = 1, fatten = 2) +
  geom_line(aes(x = time, y = att)) +
  geom_hline(yintercept = 0, colour = gray(1/2), lty = 2, lwd = 1) +
  geom_vline(xintercept = -0.5, colour = "black", lty = 1, lwd = 1) +
  theme_bw()
zp1
```

An interesting finding here. There is a positive anticipation effect: "The anticipation of marriage already increases the husbands wage".

Is this plausible?

__FEIS__

Obviously, we can also use these dummy impact function in other estimators.


```{r}
### FEIS with dummy impact function
wages2.feis <- feis(lnw ~ marry_if + enrol + yeduc + as.factor(yeargr)
                   | exp + I(exp^2), 
                   data = mwp, id = "id",
                  robust = TRUE)
summary(wages2.feis)

### Plot

# Set up results matrix
coef2.df <- data.frame(matrix(NA,
                  nrow = (length(levels(mwp$marry_if)) - 1),
                  ncol = 3))
colnames(coef2.df) <- c("time", "att", "se")

# paste results
coef2.df$time <- c(-3:14)
output <- summary(wages2.feis)$coefficients
coef2.df[, c("att", "se")] <- output[which(grepl("marry_if", rownames(output))), 1:2]

# 95% CI
interval2  <-  -qnorm((1-0.95)/2)  # 95% multiplier
coef2.df$ll <- coef2.df$att - coef2.df$se*interval2
coef2.df$ul <- coef2.df$att + coef2.df$se*interval2

# Plot
zp2 <- ggplot(coef2.df[coef2.df$time < 7, ], 
              aes(x = time, y = att)) +  
  geom_pointrange(aes(x = time, y = att, ymin = ll, ymax = ul),
                                lwd = 1, fatten = 2) +
  geom_line(aes(x = time, y = att)) +
  geom_hline(yintercept = 0, colour = gray(1/2), lty = 2, lwd = 1) +
  geom_vline(xintercept = -0.5, colour = "black", lty = 1, lwd = 1) +
  theme_bw()
zp2
```

This gives us what we already expected: using FEIS, the marital wage premium disappears.

# Dynamic Diff-in-Diff

There is an ongoing discussion on how the Difference in Differences estimator relates to the two-ways FE estimator when treatment timing varies: different individuals receive the treatment at different periods. 

@GoodmanBacon.2021 shows that the two-ways FE is a weighted average of all possbile two-group/two-period DD estimators. The weights determining how much each of these single combinations contributes to the two-ways FE are determined by the group size (e.g. how long do we observe each combination before and after treatment) and the variance in the treatment.

![Two-ways FE and DD with varying treatment timing [@GoodmanBacon.2021].](fig/goodman.jpg)

For instance, those who are treated in later time periods are not only compared to those who are never treated but also to those who have already been treated in earlier periods.

Especially for "trend-breaking" treatment effects like in the following figure, this will lead to biased estimates of the average treatment effect [@GoodmanBacon.2021; @Meer.2016].

![Bias of two-ways FE with trend-breaking treatment [@GoodmanBacon.2021].](fig/goodman2.jpg)

In this example, in the middle period, we compare the break in treand in the early tread with the late treated, and we see the divergence between those two groups. However, for the later treated (right third), the earlier treated are the control cases, and we do not observe that there is actually a break in trend.

One way of counteracting this problem is to use event study / impact function designs (see above) to explicitly model time varying treatment effects.

### Callaway & Sant’Anna dynamic Diff-in-Diff

A second way is the application of __flexible Diff-in-Diff__ estimators as proposed by @Callaway.2020.

Remember, formally we can write the $2 \times 2$ Diff-in-Diff estimator as

$$
ATT = \E(\Delta y_{T}) - \E(\Delta y_{C}) = (\E(y_{T}^{post}) - \E(y_{T}^{pre})) - (\E(y_{C}^{post}) - \E(y_{C}^{pre})).
$$

@Callaway.2020 show that we can generalize this $2 \times 2$ Diff-in-Diff to a mutlti-group and multi-timing setting by computing group-time average treatment effects. We group all treatment units which receive treatment at the same period into a common group $g$, and for each treatment-group $g$ and time period $t$ we estimate group-specific and time-specific ATTs: 

$$
ATT_{g,t} = \E(\Delta y_{g}) - \E(\Delta y_{C}) = (\E(y_{g}^{t}) - \E(y_{g}^{g-1})) - (\E(y_{C}^{t}) - \E(y_{C}^{g-1})),
$$

where the control group can either be the never-treated or the not-yet-treated.

Intuitively, this means, we estimate an individual treatment effect for each combination of treatment-timing-group and control group.

Obviously, this gives us a large number of different treatment effects. So, in a second step, we re-aggregate these individual combinations back to goup or time averaged treatment effect. In an event study design, propose the following dynamic treatment effect:

$$
  \theta_D(e) := \sum_{g=2}^T \mathbf{1} \{ g + e \leq T \} ATT(g,g+e) P(G=g | G+e \leq T),
$$
where $e$ specifies for how long a unit has been exposed to the treatment.

For a more detailled introdution see @Callaway.2020 or the respective [package introcution](https://cran.r-project.org/web/packages/did/vignettes/multi-period-did.html).

Assumptions:

TBD


### Example

How does that look in our marriage example? To estimate the dynamic DD we use the `did` package, as describes in more detail [here](https://cran.r-project.org/web/packages/did/vignettes/did-basics.html) or in the authors [blog](https://pedrohcgs.github.io/posts/twfe).

__Note: This package works witch staggered treatment adoption! We thus should perform all the steps we have performed above to restrict and prepare the data!__

As a first step, we need to define a variable that contains the treatment timing: the first year an ever-treated individual is treated.

This should be a positive number for all observations in treated groups. It defines which "group" a unit belongs to. It should be 0 for units in the untreated group.

```{r}
# treatment timing = year if married
mwp$treat_timing <- ifelse(mwp$marry == 1, mwp$year, NA)

# set never treated to zero
mwp$treat_timing[mwp$evermarry == 0] <- 0

# if married is not NA, used min year per id (removing NAs)
mwp$treat_timing[!is.na(mwp$marry)] <- ave(mwp$treat_timing[!is.na(mwp$marry)],
                                           mwp$id[!is.na(mwp$marry)],
                                           FUN = function(x) min(x, na.rm = TRUE))


head(mwp[, c("id", "year", "marry", "evermarry", "treat_timing")], n = 35)
```



```{r}
# estimate group-time average treatment effects using att_gt method
wages.attgt <- att_gt(yname = "lnw",
                      tname = "year",
                      idname = "id",
                      gname = "treat_timing",
                      #xformla = ~ enrol + yeduc + exp + I(exp^2), # note that we omit the yeargroup here
                      data = mwp,
                      allow_unbalanced_panel = TRUE,
                      control_group = "notyettreated",
                      est_method = "ipw"
                        )
```

One huge advantage: We do not need to make a decision about which periods (before treatment) we want to include, and which observations go into the reference category. 

However, we get a lot of individual treatment effects.

```{r}
# showing the first 30
summary(wages.attgt)
```

These individual effects are similar to running a lot of individual regressions, where we compute a lot of individual $2 \times 2$ DD estimators, e.g. for group 1981:

```{r}
t <- 1981

# run individual effects
for(i in sort(unique(mwp$year))[-1]){
  
  # not yet treated
  mwp$notyettreated <- ifelse(mwp$treat_timing > t & mwp$treat_timing > i, 1, 0)
  
  # select 1980 group, never-treated and not yet treated
  oo <- which(mwp$treat_timing == t | mwp$treat_timing == 0 | mwp$notyettreated == 1)
  df <- mwp[oo, ]
  
  # after set to 1 for year rolling year i
  df$after <- NA
  df$after[df$year == i] <- 1 
  
  # control year
  if(i < t){
    # if i is still before actual treatment, compare to previous year
    tc <- i - 1
  }else{
    # if i is beyond actual treatment, compare to year before actual treatment (t-1)
    tc <- t - 1
  }
  df$after[df$year == tc] <- 0
  
  # Restrict to the two years we want to compare
  df <- df[!is.na(df$after), ]
  
  # Define treated group
  df$treat <- ifelse(df$treat_timing == t, 1, 0)
  
  # Estiamte 2x2 DD
  tmp.lm <- lm(lnw ~ treat*after, data = df)
  
  # Print
  print(paste0(i, ": ", round(tmp.lm$coefficients[4], 4)))
}
```

To make this more interpretable, we re-aggregate the individuals results to a dynamic time-averaged effect (we now restrict this to observations from -3 to 6).

```{r}
wages.dyn <- aggte(wages.attgt, type = "dynamic", na.rm = TRUE,
                   min_e = -3, max_e = 6)
summary(wages.dyn)
```

The `did` package also comes with a handy command `ggdid()` to plot the results 

```{r}
zp3 <- ggdid(wages.dyn) 
  
zp3 <- zp3 + 
  geom_hline(yintercept = 0, colour = gray(1/2), lty = 2) +
  geom_vline(xintercept = -0.5, colour = "black", lty = 1)

zp3
```

Although it is definitely not the same, this doesn't look too different from our earlier FEIS results. 

# References

